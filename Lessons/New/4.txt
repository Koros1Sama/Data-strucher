--- Slide 1 ---
Indexing Structures for Files and Physical Database Design

--- Slide 2: Indexes as Access Paths ---
A single-level index is an auxiliary file that makes it more efficient to search for a record in the data file.
The index is usually specified on one field of the file (although it could be specified on several fields)
One form of an index is a file of entries <field value, pointer to record>, which is ordered by field value
The index is called an access path on the field.

--- Slide 3: Indexes as Access Paths (contd.) ---
The index file usually occupies considerably less disk blocks than the data file because its entries are much smaller
A binary search on the index yields a pointer to the file record
Indexes can also be characterized as dense or sparse 
A dense index has an index entry for every search key value (and hence every record) in the data file. 
A sparse (or nondense) index, on the other hand, has index entries for only some of the search values

--- Slide 4: Index ---
Example: Given the following data file EMPLOYEE(NAME, SSN, ADDRESS, JOB, SAL, ... )
Suppose that:
	record size R=150 bytes	block size B=512 bytes	r=30000 records
Then, we get:
	blocking factor Bfr= B div R= 512 div 150= 3 records/block
	number of file blocks b= (r/Bfr)= (30000/3)= 10000 blocks
For an index on the SSN field, assume the field size VSSN=9 bytes, assume the record pointer size PR=7 bytes. Then:
	index entry size RI=(VSSN+ PR)=(9+7)=16 bytes
	index blocking factor BfrI= B div RI= 512 div 16= 32 entries/block
	number of index blocks b= (r/ BfrI)= (30000/32)= 938 blocks
	binary search needs log2bI= log2938= 10 block accesses
	This is compared to an average linear search cost of:
(b/2)= 30000/2= 15000 block accesses
	If the file records are ordered, the binary search cost would be:
log2b=  log230000= 15 block accesses

--- Slide 5: Types of Single-Level Indexes ---
Primary Index
Defined on an ordered data file
The data file is ordered on a key field
Includes one index entry for each block in the data file; the index entry has the key field value for the first record in the block, which is called the block anchor
A similar scheme can use the last record in a block.
A primary index is a nondense index, since it includes an entry for each disk block of the data file and the keys of its anchor record rather than for every search value.

--- Slide 6: Primary index on the ordering key field ---

--- Slide 7: Types of Single-Level Indexes ---
Clustering Index
Defined on an ordered data file
The data file is ordered on a non-key field unlike primary index, which requires that the ordering field of the data file have a distinct value for each record.
Includes one index entry for each distinct value of the field; the index entry points to the first data block that contains records with that field value.
It is another example of nondense index where Insertion and Deletion is relatively straightforward with a clustering index.

--- Slide 8: Clustering Index Example ---

--- Slide 9: Types of Single-Level Indexes ---
Secondary Index
A secondary index provides a secondary means of accessing a file for which some primary access already exists.
The secondary index may be on a field which is a candidate key and has a unique value in every record, or a non-key with duplicate values.
The index is an ordered file with two fields.
The first field is of the same data type as some non-ordering field of the data file that is an indexing field. 
The second field is either a block pointer or a record pointer.
There can be many secondary indexes (and hence, indexing fields) for the same file.
Includes one entry for each record in the data file; hence, it is a dense index

--- Slide 10: Example of a Dense Secondary Index ---

--- Slide 11: An Example of a Secondary Index ---

--- Slide 12: Properties of Index Types ---

--- Slide 13: Dynamic Multilevel Indexes Using B-Trees and B+-Trees ---
Most multi-level indexes use B-tree or B+-tree data structures because of the insertion and deletion problem
This leaves space in each tree node (disk block) to allow for new index entries
These data structures are variations of search trees that allow efficient insertion and deletion of new search values.
In B-Tree and B+-Tree data structures, each node corresponds to a disk block
Each node is kept between half-full and completely full

--- Slide 14: Dynamic Multilevel Indexes Using B-Trees and B+-Trees (contd.) ---
An insertion into a node that is not full is quite efficient
If a node is full the insertion causes a split into two nodes
Splitting may propagate to other tree levels
A deletion is quite efficient if a node does not become less than half full
If a deletion causes a node to become less than half full, it must be merged with neighboring nodes

--- Slide 15: Difference between B-tree and B+-tree ---
In a B-tree, pointers to data records exist at all levels of the tree
In a B+-tree, all pointers to data records exists at the leaf-level nodes
A B+-tree can have less levels (or higher capacity of search values) than the corresponding B-tree